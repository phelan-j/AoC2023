pub fn part_one<I>(lines: I) -> usize
    where I : Iterator<Item = String> {
        
        /*
        let mut sum = 0;
        for line in lines {
            let a = get_possible_arrangements(&line);
            println!("sum for {line}: {a}");
            sum += a;
        }
        sum
        */
//        /*
//
//        let test = "?#?#?#?#?#?#?#? 1,3,1,6"; 
        let test = "?###???????? 3,2,1";
        let a = get_possible_arrangements(test);
        a
//        */
}

fn get_possible_arrangements(line: &str) -> usize {
    println!("{line}");
    if let Some(i) = line.find(" ") {
        let springs = &line[0..i];
        let mut group_sum = 0;
        let mut groups : Vec<usize> = Vec::new();
        for s in line[i+1..].split(",") {
            let g = s.parse::<usize>().unwrap();
            group_sum += g;
            groups.push(g);
        }
        return calculate_combinations(&springs, &groups, group_sum, 0)
    }
    0
}

fn calculate_combinations(springs: &str, groups: &[usize], group_sum: usize, depth: usize) -> usize {
    // debug
    let debug_g : Vec<String> = groups.iter().map(|s| s.to_string()).collect();
    let debug_g : String = debug_g.join(",");

    let debug_p = vec!['-'; depth as usize];
    let debug_p : String = debug_p.iter().collect();
    println!("{debug_p}>springs: {springs}, groups: {debug_g}, group_sum: {group_sum}");

    if group_sum < 0 { return 1 }

    let n = springs.len();
    if n < group_sum { return 0 }
    let n = n - group_sum;
    if groups.len() == 0 { return 1; }
    if springs.len() == 0 { return 1; }
    let spring_chars : Vec<char> = springs.chars().collect();
    let mut sum = 0;

    for i_s in 0..=n {
        let mut debug_s : Vec<char> = vec![' '; springs.len()];
        debug_s[i_s] = 's';

        let debug_s : String = debug_s.iter().collect();
        println!("{debug_p}>{springs} {debug_g}, group_sum: {group_sum}");
        println!("{debug_p}>{debug_s}");

        let g_s = groups[0];
        let mut g = g_s;
        let mut i = i_s;
        let mut c = spring_chars[i];
        loop {
            if g < 1 { break; }
            if i >= springs.len() { break; }
            if spring_chars[i] == '.' { break; }
            let mut debug_i : Vec<char> = vec![' '; springs.len() + 1];
            debug_i[i] = 'i';
            let debug_i : String = debug_i.iter().collect();
            println!("{debug_p}>{springs} {debug_g}, looping, g: {g}");
            println!("{debug_p}>{debug_s}");
            println!("{debug_p}>{debug_i}");
            g -= 1;
            i += 1;
        }
        let mut debug_i : Vec<char> = vec![' '; springs.len() + 1];
        debug_i[i] = 'i';
        let debug_i : String = debug_i.iter().collect();
        println!("{debug_p}>{springs} {debug_g}, done looping, g: {g}");
        println!("{debug_p}>{debug_s}");
        println!("{debug_p}>{debug_i}");
        if g == 0 {
            if i < springs.len() - 1 {
                c = spring_chars[i];
                if c != '#' {
                    println!("{debug_p}>recursing...");
                    let r = calculate_combinations(&springs[i+1..], &groups[1..], group_sum - g_s, depth + 1);
                    sum += r;
                    println!("{debug_p}>{springs} {debug_g}, r: {r}, sum: {sum}");
                }
                i += 1;
            }
            else {
                sum += 1;
                println!("{debug_p}>end of string, sum += 1, sum: {sum}");
            }
        }
        if spring_chars[i_s] == '#' { break; }
    }
    println!("{debug_p}>returning sum: {sum}");
    sum
}
